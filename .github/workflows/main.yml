name: Full deploy (infra → backend → frontend)

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'terraform/**'
  workflow_dispatch:

concurrency:
  group: terraform-deploy
  cancel-in-progress: true

env:
  TF_DIR: terraform/infra
  SERVICES_DIR: terraform/services
  BACKEND_DIR: backend
  FRONTEND_DIR: frontend

jobs:
  infra:
    name: Infra (terraform infra)
    runs-on: ubuntu-latest
    outputs:
      db_host: ${{ steps.tf_outputs.outputs.db_host }}
      db_user: ${{ steps.tf_outputs.outputs.db_user }}
      db_name: ${{ steps.tf_outputs.outputs.db_name }}
      vpc_connector_id: ${{ steps.tf_outputs.outputs.vpc_connector_id }}
      backend_repo: ${{ steps.tf_outputs.outputs.backend_repo }}
      frontend_repo: ${{ steps.tf_outputs.outputs.frontend_repo }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.5.7'
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN2 }}

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Configure gcloud
        run: |
          gcloud config set project ${{ secrets.GCP_PROJECT }}
          gcloud config set run/region ${{ secrets.GCP_REGION }}
          gcloud auth configure-docker ${{ secrets.GCP_REGION }}-docker.pkg.dev --quiet

      - name: Enable required GCP APIs
        run: |
          gcloud services enable servicenetworking.googleapis.com \
                                 vpcaccess.googleapis.com \
                                 run.googleapis.com \
                                 compute.googleapis.com \
                                 artifactregistry.googleapis.com \
                                 sqladmin.googleapis.com

      - name: Terraform init
        run: |
          cd $TF_DIR
          rm -rf .terraform || true
          rm -f .terraform.lock.hcl || true
          terraform init -input=false -upgrade

      - name: Terraform apply
        run: |
          cd $TF_DIR
          terraform apply -auto-approve

      - name: Read terraform outputs
        id: tf_outputs
        run: |
          cd $TF_DIR
          echo "db_host=$(terraform output -raw db_private_ip)" >> $GITHUB_OUTPUT
          echo "db_user=$(terraform output -raw db_user)" >> $GITHUB_OUTPUT
          echo "db_name=$(terraform output -raw db_name)" >> $GITHUB_OUTPUT
          echo "vpc_connector_id=$(terraform output -raw vpc_connector_id)" >> $GITHUB_OUTPUT
          echo "backend_repo=$(terraform output -raw backend_repo)" >> $GITHUB_OUTPUT
          echo "frontend_repo=$(terraform output -raw frontend_repo)" >> $GITHUB_OUTPUT

  build-backend:
    name: Build & push backend image
    runs-on: ubuntu-latest
    needs: [import-common, infra]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure gcloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Configure docker auth
        run: |
          gcloud auth configure-docker ${{ secrets.GCP_REGION }}-docker.pkg.dev --quiet

      - name: Build and push backend
        id: build
        env:
          REGION: ${{ secrets.GCP_REGION }}
          PROJECT: ${{ secrets.GCP_PROJECT }}
          BACKEND_REPO: ${{ needs.infra.outputs.backend_repo }}
          DB_HOST: ${{ needs.infra.outputs.db_host }}
          DB_USER: ${{ needs.infra.outputs.db_user }}
          DB_PASS: ${{ secrets.DB_PASS }}
          DB_NAME: ${{ needs.infra.outputs.db_name }}
        run: |
          echo "BACKEND_REPO from infra: ${BACKEND_REPO}"
          if [ -z "${BACKEND_REPO}" ]; then
            echo "ERROR: backend_repo is empty (infra outputs). Cannot build/push backend image." >&2
            exit 1
          fi
          echo "REGION: ${REGION}"
          echo "PROJECT: ${PROJECT}"
          echo "BACKEND_REPO: ${BACKEND_REPO}"
          IMAGE="${REGION}-docker.pkg.dev/${PROJECT}/${BACKEND_REPO}/store-backend:${GITHUB_SHA::8}"
          echo "Constructed IMAGE: ${IMAGE}"
          docker build --build-arg DB_SERVER_IP=${DB_HOST} -t "$IMAGE" "$GITHUB_WORKSPACE/${{ env.BACKEND_DIR }}"
          BUILD_EXIT_CODE=$?
          echo "Docker build exit code: ${BUILD_EXIT_CODE}"
          if [ "$BUILD_EXIT_CODE" -ne 0 ]; then
            echo "ERROR: Docker build failed." >&2
            exit 1
          fi

          # Push with retries (network flakiness can cause transient failures)
          for i in 1 2 3; do
            if docker push "$IMAGE"; then
              echo "Docker push successful on attempt $i."
              break
            fi
            echo "docker push failed, retrying ($i)" >&2
            sleep $((i * 3))
            if [ "$i" -eq 3 ]; then
              echo "ERROR: docker push failed after retries" >&2
              exit 1
            fi
          done

          # Read the pushed image digest from the local docker metadata so we
          # pass an immutable image reference to Terraform (image@sha256:...)
          # Wait until the registry returns the image manifest (artifact registry
          # may take a short time to become consistent). Use docker manifest inspect
          # which queries the remote registry after docker auth was configured.
          for j in 1 2 3 4 5; do
            if docker manifest inspect "$IMAGE" >/dev/null 2>&1; then
              break
            fi
            echo "Waiting for registry to expose image manifest (attempt $j)" >&2
            sleep $((j * 2))
            if [ "$j" -eq 5 ]; then
              echo "WARNING: image manifest not available after retries; continuing with tag reference" >&2
            fi
          done

          # Always output the image tag as a fallback, even if digest is not available
          echo "DEBUG: IMAGE value before output: $IMAGE"
          echo "DEBUG: IMAGE value before output: $IMAGE"
          # Persist the image reference to both GITHUB_OUTPUT (for step-level debugging)
          # and to a small file which we'll upload as an artifact so downstream
          # jobs can read it. Using an artifact avoids GitHub blocking job outputs
          # when the job environment contains repository secrets.
          echo "backend_image=$IMAGE" >> $GITHUB_OUTPUT || true
          echo "$IMAGE" > backend-image.txt

      - name: Upload backend image artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-image
          path: backend-image.txt

  import-common:
    name: Import common resources
    runs-on: ubuntu-latest
    needs: [infra]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.5.7'
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN2 }}

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Import existing common resources (if any)
        run: |
          bash scripts/import-common.sh ${{ secrets.GCP_PROJECT }} ${{ secrets.GCP_REGION }} || true

  deploy-backend:
    name: Deploy backend service
    runs-on: ubuntu-latest
    needs: [build-backend]
    outputs:
      backend_url: ${{ steps.deploy.outputs.backend_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download backend image artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-image
          path: ./artifacts

      - name: Read backend image from artifact
        id: read_backend_image
        run: |
          if [ -f ./artifacts/backend-image.txt ]; then
            IMAGE=$(cat ./artifacts/backend-image.txt)
            echo "Read backend image from artifact: $IMAGE"
            echo "backend_image=$IMAGE" >> $GITHUB_OUTPUT
          else
            echo "WARN: backend-image artifact not found; BACKEND_IMAGE will be empty" >&2
          fi

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.5.7'
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN2 }}

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Terraform init (backend)
        working-directory: ${{ env.SERVICES_DIR }}/backend
        run: |
          terraform init -input=false -upgrade

      - name: Terraform apply (backend)
        id: deploy
        env:
          BACKEND_IMAGE: ${{ steps.read_backend_image.outputs.backend_image }}
          GCP_PROJECT: ${{ secrets.GCP_PROJECT }}
          GCP_REGION: ${{ secrets.GCP_REGION }}
          DB_PASS: ${{ secrets.DB_PASS }}
        working-directory: ${{ env.SERVICES_DIR }}/backend
        run: |
          # Terraform commands run in the service directory (working-directory)

          # If the backend image variable is empty, try to fall back to the
          # currently deployed image on Cloud Run (so we don't overwrite with
          # an empty value). This makes deploy idempotent when build fails.
          SERVICE_NAME="store-backend"
          if [ -z "${BACKEND_IMAGE}" ]; then
            echo "BACKEND_IMAGE is empty; attempting to discover currently deployed image from Cloud Run..."
            EXISTING_IMAGE=""
            # Try a few possible gcloud output paths (format differs by API version)
            EXISTING_IMAGE=$(gcloud run services describe ${SERVICE_NAME} --region=${GCP_REGION} --project=${GCP_PROJECT} --format='value(status.template.containers[0].image)' 2>/dev/null || true)
            if [ -z "$EXISTING_IMAGE" ]; then
              EXISTING_IMAGE=$(gcloud run services describe ${SERVICE_NAME} --region=${GCP_REGION} --project=${GCP_PROJECT} --format='value(spec.template.spec.containers[0].image)' 2>/dev/null || true)
            fi
            if [ -z "$EXISTING_IMAGE" ]; then
              EXISTING_IMAGE=$(gcloud run services describe ${SERVICE_NAME} --region=${GCP_REGION} --project=${GCP_PROJECT} --format='value(status.template.spec.containers[0].image)' 2>/dev/null || true)
            fi
            if [ -n "$EXISTING_IMAGE" ]; then
              echo "Found existing deployed image: $EXISTING_IMAGE — using it for this apply"
              BACKEND_IMAGE="$EXISTING_IMAGE"
            else
              echo "ERROR: could not determine existing deployed image and BACKEND_IMAGE is empty — aborting" >&2
              exit 1
            fi
          fi
          if [ -z "${BACKEND_IMAGE}" ]; then
            echo "ERROR: BACKEND_IMAGE is empty. Build step failed or produced no image. Aborting deploy." >&2
            exit 1
          fi

          # Do a plan first and write the plan to a file; fail if plan fails.
          terraform plan -out=tfplan \
            -var="project_id=${GCP_PROJECT}" \
            -var="region=${GCP_REGION}" \
            -var="backend_image=${BACKEND_IMAGE}" \
            -var="db_password=${DB_PASS}"

          terraform apply -auto-approve tfplan
          echo "backend_url=$(terraform output -raw backend_url)" >> $GITHUB_OUTPUT

      - name: Wait for backend to become healthy
        run: |
          cd $SERVICES_DIR/backend || true
          BACKEND_URL="$(terraform output -raw backend_url 2>/dev/null || true)"
          if [ -z "$BACKEND_URL" ]; then
            echo "WARN: backend_url is empty after apply; skipping health checks" >&2
            exit 0
          fi

          echo "Waiting for backend to respond at $BACKEND_URL"
          for k in 1 2 3 4 5 6 7 8 9 10; do
            if curl -sf --max-time 5 "$BACKEND_URL" >/dev/null 2>&1; then
              echo "Backend is healthy"
              exit 0
            fi
            echo "Backend not ready yet (attempt $k), sleeping..."
            sleep $((k * 3))
          done

          echo "ERROR: backend did not become healthy after retries" >&2
          exit 1

  build-frontend:
    name: Build & push frontend image
    runs-on: ubuntu-latest
    needs: [deploy-backend, infra]
    outputs:
      frontend_image: ${{ steps.build_frontend.outputs.frontend_image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure gcloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Configure docker auth
        run: |
          gcloud auth configure-docker ${{ secrets.GCP_REGION }}-docker.pkg.dev --quiet

      - name: Build and push frontend
        id: build_frontend
        env:
          REGION: ${{ secrets.GCP_REGION }}
          PROJECT: ${{ secrets.GCP_PROJECT }}
          FRONTEND_REPO: ${{ needs.infra.outputs.frontend_repo }}
          BACKEND_URL: ${{ needs.deploy-backend.outputs.backend_url }}
        run: |
          if [ -z "${FRONTEND_REPO}" ]; then
            echo "ERROR: frontend_repo is empty (infra outputs). Cannot build/push frontend image." >&2
            exit 1
          fi
          IMAGE="${REGION}-docker.pkg.dev/${PROJECT}/${FRONTEND_REPO}/store-frontend:${GITHUB_SHA::8}"
          docker build --build-arg REACT_APP_API_URL=$BACKEND_URL -t "$IMAGE" "$GITHUB_WORKSPACE/${{ env.FRONTEND_DIR }}"

          for i in 1 2 3; do
            if docker push "$IMAGE"; then
              break
            fi
            echo "docker push failed, retrying ($i)" >&2
            sleep $((i * 3))
            if [ "$i" -eq 3 ]; then
              echo "ERROR: docker push failed after retries" >&2
              exit 1
            fi
          done

          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE" 2>/dev/null || true)
          if [ -n "$DIGEST" ]; then
            echo "frontend_image=$DIGEST" >> $GITHUB_OUTPUT
          else
            echo "frontend_image=$IMAGE" >> $GITHUB_OUTPUT
          fi

  deploy-frontend:
    name: Deploy frontend service
    runs-on: ubuntu-latest
    needs: [build-frontend, deploy-backend]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.5.7'
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN2 }}

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Terraform init (frontend)
        run: |
          cd $SERVICES_DIR/frontend
          terraform init -input=false -upgrade

      - name: Terraform apply (frontend)
        env:
          FRONTEND_IMAGE: ${{ needs.build-frontend.outputs.frontend_image }}
          GCP_PROJECT: ${{ secrets.GCP_PROJECT }}
          GCP_REGION: ${{ secrets.GCP_REGION }}
          BACKEND_URL: ${{ needs.deploy-backend.outputs.backend_url }}
        run: |
          cd $SERVICES_DIR/frontend
          if [ -z "${FRONTEND_IMAGE}" ]; then
            echo "ERROR: FRONTEND_IMAGE is empty. Build step failed or produced no image. Aborting deploy." >&2
            exit 1
          fi
          if [ -z "${BACKEND_URL}" ]; then
            echo "ERROR: BACKEND_URL is empty. Backend deployment may have failed. Aborting frontend deploy." >&2
            exit 1
          fi

          terraform apply -auto-approve \
            -var="project_id=${GCP_PROJECT}" \
            -var="region=${GCP_REGION}" \
            -var="frontend_image=${FRONTEND_IMAGE}" \
            -var="backend_url=${BACKEND_URL}"